---
layout: post
title: '闲扯重构'
date: 2014-08-26 09:26
comments: true
categories: [设计, 重构]
---
#为何要重构
最近，我经常思考一个问题，这个问题源自我一个做会计的朋友给我说“程序员有什么了不起的，写程序这种事情他们也会，他们经常也写一些程序、脚本来帮助他们工作。”
乔布斯就说过，每个人都应该学编程，他不仅能改变你的思维方式，还能帮助你的生活和工作。比如，我也帮女朋友写一些爬虫程序，帮他在互联网上抓一些数据。
这个问题思考后我觉得是这样的，程序员不仅仅是用编程语言来实现一个工具，而且这个工具是可维护、可移植、可复用、可维护、可扩展、可读的，就如最近公司的架构师交流会上讲师所说，编程就应该是一门艺术，你可以在别人的作品（代码、算法、设计）上微创新，做一些精进，还可以自己完成一幅大作。
因此，要让代码可维护、可移植、可复用、可维护、可扩展、可读的光是最好设计是不够的，还要不断的重构。

#代码的演进
（演进的方向一直是让代码可读、可维护、灵活等）

#从自身谈重构
重构并不是按照一个重构清单，一点一点的照做，而是一种感觉，比如，你感觉这段代码写了超过3次了，那你必须抽个方法出来；比如，你觉得在现有代码上增加一个功能不是那么容易了，那么，你也应该重新设计，让代码又可扩展性；比如，你在单元测试时候，觉得输入和输出不好写断言了，那么，你的代码相互直接的逻辑依赖就太深了，要做重构，最好让代码在语义上是可读的、函数式的（相同输入可以得到相同的输出，函数内部不改变全局环境）。

重构也不是一件一开始就要做的事情。初学编程时，总是浑浑噩噩的写代码，由于大学并不是很认真学习加上专业方向上是嵌入式，接触的大多数也是过程式的编程，写代码总是写写一些想一些。大四上的最后几个月才真正开始学Java，也慢慢会预先设计，这确实让我在开始时候节省返工的高昂成本，然后在大四下的实习时，我加强了这种预先设计的风格，而且滥用设计模式，很简单的一个模块一定要套上好几个设计模式。业内也有许多人把设计看做软件开发的关键环节，而编程只是搬砖，只是苦力活。
但是，慢慢的我又发现，有了设计我可以思考的很快，但是其中也充满了漏洞，在开发过程中和测试过程中还是要做很多设计上的返工，这意味着，在开始时候我要花更多的时间和经理在预先设计上，以避免日后的修改。我们总是在力求找到准确无误的解决方案，任何一个需求都让我们提心吊胆得猜疑。
这时候由于开始工作的公司是用敏捷开发的，我开始接触了很多敏捷思想，参加各种敏捷大会和沙龙，重构这想法也就在我耳边经常出现了。特别是XP的支持者们认为，可以完全由重构代替预先设计。
但是我觉得这太绝对了。如果你选择重构，你仍然要做预先设计，单不一定必须找到正确的解决方案，刺客你只需要得到一个足够合理的解决方案就够了。你肯定地知道，在实现这个初始解决方案的时候，你对问题的理解也会逐渐加深（项目管理课程中也提到，随着项目的实施，对项目的理解也会逐渐加深），你就会察觉到最佳解决方案和你当初想的有些不同，只要有重构在手，那这些也就不成问题，重构让日后的修改成本不再高昂。
这也是软件设计向简化前进了一大步。有一次敏捷大会上，一位讲师提到了极简（也就是乔布斯一直追求的，多一分太多，少一分太少），我觉得，通过重构也能让软件的设计达到极简的状态。
从此，我认为重构可以带来更简单的设计，同时又不损失灵活性，这也降低了设计过程的难度，减轻了设计压力。

但是，重构不是万能的银弹，如上面所说，只有当你嗅到了代码中的坏味道时候才会进行重构，这种坏味道，也就是上面说的一种感觉，只有轻松经历这种重构带来的美妙后，你就可以在感觉到这种不好的味道时候立马察觉。

#重构要注意什么，如何重构
个人觉得重构还有几个注意点：

* 如果代码在绝大部分情况下都无法正常运行了，那就别重构了，重写吧；
* 在项目结尾阶段不要进行重构，特别是在单元测试不足的情况下；
* 对于重构后接口的调整，一般是保留原接口的基础上开放新接口，然后在原先接口上注释上不推荐时候。还有就是尽可能的推迟接口的发布，因为一旦发布，你就要考虑兼容旧的接口；
* 对于数据库，只能说架构设计阶段，就应该设计数据库持久化层和service层，让数据库和业务逻辑松耦合，然后通过mock的方式就做单元测试，保证相关代码重构后依然正常，也让数据库相关代码不在是侵入式的。

对于初级的重构，个人认为注意以下几个点就好了：

* 修改变量名，更改变量名称是值得的行为吗？绝对值得，好的代码应该清楚表达出自己的功能，变量名是代码清晰地关键。任何一个傻瓜都能写出计算机可以理解的代码，惟有写出人类容易理解的代码才是优秀的程序员 
* 用简洁易懂的句法，控制一个函数类代码的数量，让一个函数只做一件事情
* 相同逻辑代码出现3次，抽方法
* 一个类中的一个方法出现与另一个类进行更多的交流时，考虑搬移函数到该类中，然后该方法中直接调用该类的新方法
* 用多态代替过多的条件判断
* 将固定的逻辑封装在父类中，把不确定的逻辑用钩子方法（回调函数）描述，通过子类（调用者）实现






















